<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Guess Up!</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  </head>
  <body>
    <!-- HEADER -->
    <header class="app-header">
      <button id="help-btn" class="icon-btn">?</button>
      <h1>Guess Up!</h1>
      <button id="settings-btn" class="icon-btn">⚙️</button>
    </header>

    <!-- DECK SELECTION GRID -->
    <main id="deck-list" class="deck-grid"></main>

    <!-- HELP MODAL -->
    <div id="help-modal" class="modal hidden">
      <div class="modal-content">
        <h2>How to Play</h2>
        <p>
          Hold the phone on your forehead so the card faces your teammates.<br />
          They give you clues. Swipe down to mark Correct;<br />
          swipe up to Skip.
        </p>
      </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settings-modal" class="modal hidden">
      <div class="modal-content">
        <h2>Settings</h2>
        <div class="setting-group">
          <label>Round Duration:</label>
          <div class="btn-group">
            <button class="duration-btn" data-seconds="60">60s</button>
            <button class="duration-btn" data-seconds="90">90s</button>
            <button class="duration-btn" data-seconds="120">120s</button>
          </div>
        </div>
        <div class="setting-group">
          <label
            ><input type="checkbox" id="sound-checkbox" checked /> Sound Effects
          </label>
        </div>
        <div class="setting-group">
          <label>Control Scheme:</label>
          <div class="btn-group">
            <button class="ctrl-scheme-btn" data-scheme="tilt">Tilt</button>
            <button class="ctrl-scheme-btn" data-scheme="touch">Touch</button>
          </div>
        </div>
      </div>
    </div>

    <!-- DECK INFO + PLAY MODAL -->
    <div id="deck-modal" class="modal hidden">
      <div class="modal-content">
        <h2 id="deck-title"></h2>
        <p id="deck-description"></p>
        <br />
        <button id="play-btn" class="primary-btn">Play!</button>
      </div>
    </div>

    <!-- GAMEPLAY VIEW -->
    <div id="gameplay-view" class="hidden">
      <div id="card-container" class="card-container">
        <div class="swipe-label swipe-up">↑ swipe up to skip</div>
        <div class="card-text"></div>
        <div class="swipe-label swipe-down">↓ swipe down for correct</div>
      </div>
      <div id="timer" class="timer">0:00</div>
    </div>

    <!-- SCORE SCREEN -->
    <div id="score-modal" class="modal hidden">
      <div class="modal-content">
        <h2 id="score-title">Score: 0</h2>
        <button id="replay-btn" class="primary-btn">Play Again</button>
        <ul id="results-list" class="results-list"></ul>
      </div>
    </div>

    <!-- AUDIO ELEMENTS -->
    <audio id="beep-audio" src="audio/beep.mp3"></audio>
    <audio id="correct-audio" src="audio/correct.mp3"></audio>
    <audio id="skip-audio" src="audio/skip.mp3"></audio>
    <audio id="roundend-audio" src="audio/round_end.mp3"></audio>
    <audio id="game-start-audio" src="audio/game_start.mp3"></audio>

    <!-- LOGIC -->
    <script type="module">
      import { decks } from "./decks.js";
      import { TiltDetector } from "./tilt-detector.js";

      // -- Element refs
      const appHeader = document.querySelector(".app-header");
      const deckList = document.getElementById("deck-list");
      const helpBtn = document.getElementById("help-btn");
      const settingsBtn = document.getElementById("settings-btn");
      const helpModal = document.getElementById("help-modal");
      const settingsModal = document.getElementById("settings-modal");
      const deckModal = document.getElementById("deck-modal");
      const playBtn = document.getElementById("play-btn");
      const deckTitleEl = document.getElementById("deck-title");
      const deckDescEl = document.getElementById("deck-description");
      const settingsCheckbox = document.getElementById("sound-checkbox");
      const durationButtons = document.querySelectorAll(".duration-btn");
      const ctrlSchemeButtons = document.querySelectorAll(".ctrl-scheme-btn");
      const gameplayView = document.getElementById("gameplay-view");
      const cardContainer = document.getElementById("card-container");
      const cardText = document.querySelector(".card-text");
      const swipeUpText = document.querySelector(".swipe-up");
      const swipeDownText = document.querySelector(".swipe-down");
      const timerEl = document.getElementById("timer");
      const scoreModal = document.getElementById("score-modal");
      const scoreTitle = document.getElementById("score-title");
      const resultsList = document.getElementById("results-list");
      const replayBtn = document.getElementById("replay-btn");

      const beepAudio = document.getElementById("beep-audio");
      const correctAudio = document.getElementById("correct-audio");
      const skipAudio = document.getElementById("skip-audio");
      const roundendAudio = document.getElementById("roundend-audio");
      const gameStartAudio = document.getElementById("game-start-audio");

      const tiltDetector = new TiltDetector({ threshold: 30, frequency: 30 });

      let roundDuration = 60;
      let ctrlScheme = "tilt";
      // Initialize active states of settings buttons
      durationButtons.forEach((btn) => {
        if (btn.dataset.seconds === `${roundDuration}`) {
          btn.classList.add("active");
        }
      });
      ctrlSchemeButtons.forEach((btn) => {
        if (btn.dataset.scheme === ctrlScheme) {
          btn.classList.add("active");
        }
      });

      let selectedDeck = null;
      let useSound = true;
      let currentCards = [];
      let currentIndex = 0;
      let score = 0,
        timerId,
        timeLeft;

      let isDragging = false;
      let dragStartY = 0;

      // -- Helper functions for dragging

      // Helper to reset card position instantly (no transition)
      function resetCard() {
        cardContainer.style.transition = "none";
        cardContainer.style.transform = "";
        // force a reflow so the next transition runs
        // (only needed if you immediately add another transition)
        void cardContainer.offsetHeight;
        cardContainer.style.transition = "transform 0.2s ease-out";
      }

      // Drag start
      function onDragStart(e) {
        if (ctrlScheme !== "touch") return;
        isDragging = true;
        dragStartY = e.clientY;
        // prevent other apps from stealing the gesture
        cardContainer.setPointerCapture(e.pointerId);
      }

      // Drag move
      function onDragMove(e) {
        if (ctrlScheme !== "touch") return;
        if (!isDragging) return;
        const deltaY = e.clientY - dragStartY;
        cardContainer.style.transform = `translateY(${deltaY}px)`;
        // if you want a little tilt, add:
        const rot = Math.sign(deltaY) * Math.min(15, Math.abs(deltaY) / 10);
        cardContainer.style.transform = `translateY(${deltaY}px) rotate(${rot}deg)`;
      }

      // Drag end / cancel
      function onDragEnd(e) {
        if (ctrlScheme !== "touch") return;
        if (!isDragging) return;
        isDragging = false;
        cardContainer.releasePointerCapture(e.pointerId);

        const deltaY = e.clientY - dragStartY;
        const threshold = 100;

        if (deltaY > threshold) {
          cardMarkedCorrect();
        } else if (deltaY < -threshold) {
          cardMarkedSkipped();
        } else {
          // Snap back
          resetCard();
        }
      }

      function cardMarkedCorrect() {
        // Animate off‐screen down
        cardContainer.style.transition = "transform 0.3s ease-in";
        cardContainer.style.transform = "translateY(100vh)";
        setTimeout(() => {
          // clean up and mark correct
          resetCard();
          markCorrect();
        }, 300);
      }

      function cardMarkedSkipped() {
        // Animate off‐screen up
        cardContainer.style.transition = "transform 0.3s ease-in";
        cardContainer.style.transform = "translateY(-100vh)";
        setTimeout(() => {
          resetCard();
          markSkip();
        }, 300);
      }

      // Hook them up **once**, e.g. after you grab cardContainer:
      cardContainer.style.touchAction = "none"; // ensure CSS is applied at runtime
      cardContainer.addEventListener("pointerdown", onDragStart);
      cardContainer.addEventListener("pointermove", onDragMove);
      cardContainer.addEventListener("pointerup", onDragEnd);
      cardContainer.addEventListener("pointercancel", onDragEnd);

      // -- Utility: show/hide
      function toggle(el, show = true) {
        el.classList.toggle("hidden", !show);
      }

      // -- Close modals on background click
      document.querySelectorAll(".modal").forEach((m) => {
        m.addEventListener("click", (e) => {
          if (e.target === m) toggle(m, false);
        });
      });

      // -- Deck grid
      function renderDecks() {
        decks.forEach((d, i) => {
          const btn = document.createElement("button");
          btn.className = "deck-card";
          btn.innerHTML = `<h3>${d.title}</h3>`;
          btn.addEventListener("click", () => openDeck(i));
          deckList.appendChild(btn);
        });
      }

      // -- Open deck info
      function openDeck(i) {
        selectedDeck = decks[i];
        deckTitleEl.textContent = selectedDeck.title;
        deckDescEl.textContent = selectedDeck.description;
        toggle(deckModal, true);
      }

      function showForeheadInstructions() {
        // Hide UI panels and show our countdown card
        toggle(appHeader, false);
        toggle(deckList, false);
        toggle(deckModal, false);
        toggle(scoreModal, false);
        toggle(helpModal, false);
        toggle(settingsModal, false);
        toggle(gameplayView, true);

        // Disable dragging on the card
        cardContainer.style.pointerEvents = "none";

        // hide timer
        toggle(timerEl, false);

        cardText.textContent = "Place on Forehead!";
      }

      // --- Countdown before game start ---
      function showCountdown() {
        return new Promise((resolve) => {
          let count = 3;
          // Hide UI panels and show our countdown card
          toggle(appHeader, false);
          toggle(deckList, false);
          toggle(deckModal, false);
          toggle(scoreModal, false);
          toggle(helpModal, false);
          toggle(settingsModal, false);
          toggle(gameplayView, true);

          // Disable dragging on the card
          cardContainer.style.pointerEvents = "none";

          // hide timer
          toggle(timerEl, false);

          cardText.textContent = "Get Ready!";

          // Play beep immediately and then every second, three times
          beepAudio.currentTime = 0;
          beepAudio.play();
          count--;
          const interval = setInterval(() => {
            if (count > 0) {
              beepAudio.currentTime = 0;
              beepAudio.play();
              count--;
            } else {
              clearInterval(interval);
              // Cleanup countdown view
              toggle(timerEl, true);
              toggle(gameplayView, false);
              cardContainer.style.pointerEvents = "auto";
              resolve();
            }
          }, 1000);
        });
      }

      // -- Start a round
      function startRound() {
        // play game‐start sound
        if (useSound) {
          gameStartAudio.currentTime = 0;
          gameStartAudio.play();
        }
        toggle(appHeader, false);
        toggle(deckList, false);
        toggle(deckModal, false);

        if (ctrlScheme === "tilt") {
          tiltDetector.addEventListener("tiltdown", (e) => {
            cardMarkedCorrect();
          });
          tiltDetector.addEventListener("tiltup", (e) => {
            cardMarkedSkipped();
          });
        }

        score = 0;
        currentCards = [...selectedDeck.cards].sort(() => Math.random() - 0.5);
        currentIndex = 0;
        timeLeft = roundDuration;
        updateCard();
        updateTimer();
        toggle(gameplayView, true);

        timerId = setInterval(() => {
          timeLeft--;
          // only beep during the final 10 seconds
          if (useSound && timeLeft > 0 && timeLeft <= 5) {
            beepAudio.currentTime = 0;
            beepAudio.play();
          }
          updateTimer();
          if (timeLeft <= 0) endRound();
        }, 1000);
      }

      // -- Update the shown card
      function updateCard() {
        cardText.textContent = currentCards[currentIndex];
      }

      // -- Update the timer display
      function updateTimer() {
        const m = String(Math.floor(timeLeft / 60)).padStart(1, "0");
        const s = String(timeLeft % 60).padStart(2, "0");
        timerEl.textContent = `${m}:${s}`;
      }

      // -- Mark correct / skip
      function markCorrect() {
        if (useSound) (correctAudio.currentTime = 0), correctAudio.play();
        score++;
        nextCard();
      }
      function markSkip() {
        if (useSound) (skipAudio.currentTime = 0), skipAudio.play();
        nextCard();
      }

      function nextCard() {
        currentIndex++;
        if (currentIndex >= currentCards.length) {
          endRound();
        } else {
          updateCard();
        }
      }

      // -- End the round
      function endRound() {
        tiltDetector.stop();
        // remove tiltDetector event listeners
        tiltDetector.removeEventListener("tiltdown", (e) => {
          cardMarkedCorrect();
        });
        tiltDetector.removeEventListener("tiltup", (e) => {
          cardMarkedSkipped();
        });

        clearInterval(timerId);

        if (useSound) (roundendAudio.currentTime = 0), roundendAudio.play();
        toggle(gameplayView, false);
        scoreTitle.textContent = `${selectedDeck.title} – Score: ${score}`;
        const seenCards = currentCards.slice(0, currentIndex);
        resultsList.innerHTML = seenCards
          .map((c, i) => `<li>${c} ${i < score ? "✅" : "❌"}</li>`)
          .join("");
        toggle(appHeader, true);
        toggle(deckList, true);
        toggle(scoreModal, true);
      }

      function startRoundWithCountdown() {
        toggle(scoreModal, false);
        if (ctrlScheme === "touch") {
          swipeUpText.textContent = "↑ swipe up to skip";
          swipeDownText.textContent = "↓ swipe down for correct";
          showCountdown().then(startRound);
          return;
        }
        // tilt controls
        swipeUpText.textContent = "↑ tilt up to skip";
        swipeDownText.textContent = "↓ tilt down for correct";
        showForeheadInstructions();
        tiltDetector.start().then(() => {
          // wait for the first “tiltdown” (i.e. forehead placement)
          const onPlaced = () => {
            tiltDetector.removeEventListener("neutral", onPlaced);
            // then kick off the 3‑2‑1 countdown + round
            showCountdown().then(startRound);
          };
          tiltDetector.addEventListener("neutral", onPlaced);
        });
      }

      // -- Event bindings
      helpBtn.addEventListener("click", () => toggle(helpModal, true));
      settingsBtn.addEventListener("click", () => toggle(settingsModal, true));
      durationButtons.forEach((b) =>
        b.addEventListener("click", (e) => {
          roundDuration = +e.target.dataset.seconds;
          durationButtons.forEach((x) => x.classList.remove("active"));
          e.target.classList.add("active");
        })
      );
      ctrlSchemeButtons.forEach((b) =>
        b.addEventListener("click", (e) => {
          ctrlScheme = e.target.dataset.scheme;
          ctrlSchemeButtons.forEach((x) => x.classList.remove("active"));
          e.target.classList.add("active");

          // *** NEW: toggle the class for showing labels ***
          if (ctrlScheme === "touch") {
            cardContainer.classList.add("touch-scheme");
          } else {
            cardContainer.classList.remove("touch-scheme");
          }
        })
      );
      settingsCheckbox.addEventListener(
        "change",
        (e) => (useSound = e.target.checked)
      );
      playBtn.addEventListener("click", () => {
        startRoundWithCountdown();
      });
      replayBtn.addEventListener("click", () => {
        startRoundWithCountdown();
      });

      // initial render
      renderDecks();
    </script>
  </body>
</html>
